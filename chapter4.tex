% !TeX root = main.tex
%===================================== CHAP 4 =================================

\chapter{B-spline MINMPC}\label{chap:b-spline-minmpc}

\section{Dynamic Model}
\subsection{Double Integrator}
The double integrator model is a simple model that ensures a continuous position, velocity, and acceleration for the ship. The model is described by the following equations:
\begin{subequations}\label{eq:double-integrator}
    \begin{align}
        \dot{\mathbf{p}}(t) &= \mathbf{v}(t), \label{eq:double-integrator-x} \\
        \dot{\mathbf{v}}(t) &= \mathbf{a}(t), \label{eq:double-integrator-v} \\
        \|\mathbf{v}(t)\|_2 &\leq v_{\max}, \label{eq:double-integrator-vmax} \\
        \|\mathbf{a}(t)\|_2 &\leq a_{\max}, \label{eq:double-integrator-a}
    \end{align}
\end{subequations}
where $\mathbf{p} = [p_N, p_E]^\top$ denotes the position of the ship, $\mathbf{v} = [v_N, v_E]^\top$ is the velocity, and $\mathbf{a} = [a_N, a_E]^\top$ is the acceleration in North-East coordinates. The $\|\cdot\|_2$ notation denotes the Euclidean norm, and $v_{\max}$ and $a_{\max}$ are the maximum speed and acceleration of the ship, respectively.

This continuous model can be relaxed to a B-spline model by letting $\mathbf{p}(x)$, $\mathbf{v}(x)$, and $\mathbf{a}(x)$ be spline functions on a chosen B-spline basis. It is desirable to let time be a variable in the optimization problem so that minimum time trajectories can be found. It is impractical to let the knot values of the B-spline representation of $\mathbf{p}(x)$ be optimization variables as an analysis of the Cox-de Boor recursion formula in \cref{eq:b-spline-recurrence} shows that the spline function is non-linear in these knot values. More specifically a degree $p$ B-spline with the parameter $x$ fixed, will be a polynomial of degree $p$ in the knot values. Instead, the time variable $t$ is introduced as a function of the parameter $x$, which is a common approach in these types of problems \citep{mercy2017spline,ShortestPathsConvexSets}. 

With this approach, the velocity and acceleration can now be expressed as
\begin{subequations}\label{eq:double-integrator-spline}
    \begin{align}
        \mathbf{v}(t) &= \frac{\partial \mathbf{p}}{\partial x} \frac{\partial x}{\partial t} = \frac{\mathbf{p}'}{t'},
        \label{eq:double-integrator-v-spline} \\
        \mathbf{a}(t) &= \frac{\partial \mathbf{v}}{\partial t} = \frac{\partial}{\partial t} \left(\frac{\mathbf{p}'}{t'}\right) = 
        \frac{
            t'\frac{\partial \mathbf{p}'}{\partial t} - \mathbf{p}'\frac{\partial t'}{\partial t}
            }{(t')^2} = 
        \frac{\mathbf{p}'' - \mathbf{p}'\frac{t''}{t'}}{(t')^2}.
        \label{eq:double-integrator-a-spline}
    \end{align}
\end{subequations}
Here $(\cdot)'$ and $(\cdot)''$ denotes the first and second derivative with respect to the parameter $x$, respectively. In \cref{eq:double-integrator-spline}, the inverse function theorem was used to flip the relation between $t$ and $x$. This is only possible if $t$ is a strictly increasing function of $x$, which is the case if the constraint 
\begin{equation}\label{eq:constraint-t}
    t'(x) > 0
\end{equation}
holds.  
If we in addition require the time to be positive, the velocity constraint in \cref{eq:double-integrator-vmax} becomes
\begin{equation}\label{eq:double-integrator-vmax-spline}
    \begin{aligned}
        &&\|\mathbf{v}(t)\|_2 = \left\|\frac{\mathbf{p}'}{t'}\right\|_2 &\leq v_{\max} \\
        &\implies& \|\mathbf{p}'(x)\|_2 &\leq t'(x)v_{\max} \\
        &\implies& \mathbf{p}'(x)\cdot\mathbf{p}'(x) &\leq (t'(x))^2v_{\max}^2.
    \end{aligned}
\end{equation}
To simplify the model, yet another restriction is put on the time function $t(x)$ by requiring it to be a 1st degree B-spline function. This means that the time variable is a piecewise linear function of the parameter $x$, and the second derivative of $t$ is zero, giving the simplified acceleration constraint
\begin{equation}\label{eq:double-integrator-a-spline-simplified}
    \begin{aligned}
        &&\|\mathbf{a}(t)\|_2 = \left\|\frac{\mathbf{p}''}{(t')^2}\right\|_2 &\leq a_{\max} \\
        &\implies& \|\mathbf{p}''(x)\|_2 &\leq (t'(x))^2a_{\max} \\
        &\implies& \mathbf{p}''(x)\cdot\mathbf{p}''(x) &\leq (t'(x))^4a_{\max}^2.
    \end{aligned}
\end{equation}

Now the B-Spline relaxation is fully given by the following equations:
\begin{subequations}\label{eq:double-integrator-spline-complete}
    \begin{align}
        \mathbf{p}(x) &= \sum_{i=0}^{n} \mathbf{p}_i B_{i,p,\mathbf{t}}(x), \label{eq:double-integrator-spline-complete-p} \\
        t(x) &= \sum_{i=0}^{m} t_i B_{i,1,\boldsymbol{\tau}}(x), \label{eq:double-integrator-spline-complete-t} \\
        \mathbf{p}'(x) \cdot \mathbf{p}'(x) &\leq (t'(x))^2v_{\max}^2, \label{eq:double-integrator-spline-complete-vmax} \\
        \mathbf{p}''(x) \cdot \mathbf{p}''(x) &\leq (t'(x))^4a_{\max}^2, \label{eq:double-integrator-spline-complete-a} \\
        t(x) &\geq 0, \label{eq:double-integrator-spline-complete-t-constraint} \\
        t'(x) &> 0. \label{eq:double-integrator-spline-complete-t-derivative} \end{align}
\end{subequations}
The only optimization variables needed are the B-Spline coefficients $\mathbf{p}_i\in\mathbb{R}^2$ and $t_i\in\mathbb{R}^+$ from \cref{eq:double-integrator-spline-complete-p,eq:double-integrator-spline-complete-t}, which are subject to the constraints \cref{eq:double-integrator-spline-complete-vmax,eq:double-integrator-spline-complete-a,eq:double-integrator-spline-complete-t-constraint,eq:double-integrator-spline-complete-t-derivative}.


\subsection{Dubins Model}
The ship dynamics are represented using Dubins model (unicycle model), which escribes a vehicle moving in a plane where the velocity points in the direction of the heading:
\begin{subequations}\label{eq:dubins-model}
    \begin{align}
        \dot x &= V \cos(\chi),       \label{eq:dubins-x} \\
        \dot y &= V \sin(\chi),       \label{eq:dubins-y} \\
        \dot \chi &= \omega,          \label{eq:dubins-chi} \\
        |\omega| &\leq \omega_{\max}, \label{eq:dubins-omega} \\
        0 \leq V &\leq V_{\max},      \label{eq:dubins-V} 
    \end{align}
\end{subequations}
where $x$ and $y$ are the position coordinates, $V$ is the speed, and $\chi$ is the heading angle. The control input is the turn rate $\omega$.

In order to perform a B-spline relaxation on this model, all symbols in \cref{eq:dubins-model} need to be polynomial functions of each other. One way to  achieve this, is to use the tangent half-angle substitution
\begin{equation}\label{eq:tangent-half-angle}
    r \defeq \tan\left(\frac{\chi}{2}\right).
\end{equation}
In this section, the $\defeq$ symbol denotes a change of variables, to avoid confusion with the $=$ symbol used for equality in constraints. 

Now $\cos(\chi)$ and $\sin(\chi)$ can be expressed in terms of $r$ as
\begin{subequations}\label{eq:cos-sin-r}
    \begin{align}
        \cos(\chi) &\defeq \frac{1 - r^2}{1 + r^2}, \label{eq:cos-r} \\
        \sin(\chi) &\defeq \frac{2r}{1 + r^2}.      \label{eq:sin-r}
    \end{align}
\end{subequations}
To find polynomial expressions for $\dot x$ and $\dot y$, the variable $\tilde v$ is intruduced to satisfy the equation
\begin{equation}\label{eq:constraint-V}
    V = \tilde v (1 + r^2).
\end{equation}
Now, \cref{eq:dubins-x,eq:dubins-y} can be written as
\begin{subequations}\label{eq:dubins-xy}
    \begin{align}
        \dot x &= \tilde v (1 - r^2), \label{eq:dubins-x-r} \\
        \dot y &= 2\tilde v r.        \label{eq:dubins-y-r}
    \end{align}
\end{subequations}

Up to this point, the derivation in this section has been based on the work of \citet{mercy2017spline}, which used the bicycle model. The next step is to find a polynomial expression for \cref{eq:dubins-chi} in terms of $r$ and $\omega$. This is done by first differentiating \cref{eq:tangent-half-angle} with respect to time
\begin{equation}\label{eq:rdot}
    \begin{aligned}
        &&\atan(r) &= \frac{\chi}{2}, \\
        &\implies& \frac{1}{1 + r^2} \dot r &= \frac{1}{2} \dot \chi, \\
        &\implies& \dot r &= \frac{1}{2} \dot \chi (1 + r^2),
    \end{aligned}
\end{equation}
before substituting \cref{eq:dubins-chi} into \cref{eq:rdot} to get
\begin{equation}\label{eq:rdot-omega}
    \dot r = \frac{1}{2} \omega (1 + r^2),
\end{equation}
where the dot notation denotes differentiation with respect to time.
To fulfill the constraint on $\omega$ in \cref{eq:dubins-omega}, \cref{eq:rdot-omega} is solved for $\omega$ to get
\begin{equation}\label{eq:omega-r}
    \omega \defeq \frac{2 \dot r}{1 + r^2}.
\end{equation}
Substituting \cref{eq:omega-r} into \cref{eq:rdot-omega} gives
\begin{equation}\label{eq:rdot-omega-r}
    \left|\frac{2 \dot r}{1 + r^2}\right| \leq \omega_{\max},
\end{equation}
which can be split into the two polynomial constraints
\begin{subequations}\label{eq:rdot-omega-r-constraints}
    \begin{align}
        2 \dot r &\leq \omega_{\max} (1 + r^2), \label{eq:rdot-omega-r-constraint1} \\
        2 \dot r &\geq -\omega_{\max} (1 + r^2). \label{eq:rdot-omega-r-constraint2}
    \end{align}
\end{subequations}
The speed constraint in \cref{eq:dubins-V} can similarly be expressed in terms of $r$ and $\tilde v$ as
\begin{subequations}\label{eq:V-r}
    \begin{align}
        \tilde v &\ge 0, \\
        \tilde v (1 + r^2) &\leq V_{\max}.
    \end{align}
\end{subequations}

The full model is implemented by letting $r(t)$ and $\tilde v(t)$ be spline functions on a chosen B-spline basis under the constraints in \cref{eq:rdot-omega-r-constraints,eq:V-r}, using the expressions in \cref{eq:dubins-xy} to calculate $\dot x$ and $\dot y$ using the algorithms in \cref{chap:b-spline-theory}. Notice that $V$, $\chi$, and $\omega$ are now entirely removed from the model, which is fully described by $r$ and $\tilde v$. The coefficients of the B-spline representation of $\dot r$ are simply linear combinations of the coefficients of $r$, as explained in \cref{sec:derivative} and the position can be found by integrating the expressions in \cref{eq:dubins-xy}.

To implement the inequality constraint $f(t) \le g(t)$, for two spline functions $f(t)$ and $g(t)$, the constraint is enforced by ensuring the coefficients of the B-spline representation of $f(t) - g(t)$ are non-positive, exploiting the convex hull property of B-splines. 

\section{Target Ships}
\begin{itemize}
    \item hyperplane separation theorem
    \item COLREGS constraints
    \item mixed integer programming
\end{itemize}

\subsection{Hyperplane Separation Theorem}
The standard way to enforce collision constraints between the OS and TS is to apply a minumum distance constraint between the two ships as
\begin{equation}\label{eq:minimum-distance}
    (\mathbf p_{\text{OS}} - \mathbf p_{\text{TS}}) \cdot (\mathbf p_{\text{OS}} - \mathbf p_{\text{TS}}) \geq d_{\text{min}}^2,
\end{equation}
where $\mathbf p_{\text{OS}}$ and $\mathbf p_{\text{TS}}$ are the positions of the OS and TS, respectively, and $d_{\text{min}}$ is the minimum distance between the two ships. The $\cdot$ symbol denotes the dot product. 

The hyperplane separation theorem states that for two disjoint convex sets $\mathcal A$ and $\mathcal B$, there exists $\mathbf n\in \mathbb R^n\backslash\{\mathbf0\}$ and $b\in\mathbb R$ such that the hyperplane $H=\{\mathbf x\in\mathbb R^n \mid \mathbf n^\top \mathbf x = b\}$ separates $\mathcal A$ and $\mathcal B$ \citep{Boyd2004-ih}. In other words, there exists a function $a^\top x - b$ that is non-negative for all $x \in \mathcal A$ and non-positive for all $x \in \mathcal B$. 

Using this theorem the collision avoidance problem can essentially be transformed into a classification problem. The objective is to find a line that separates points $\mathbf p_i$ representing the OS from points $\mathbf q_j$ belonging to the TS.
\begin{subequations}\label{eq:minimum-distance-hyperplane}
    \begin{align}
        \mathbf p_{i}(t) \cdot{\mathbf n}(t) &\ge b(t), \quad\forall \mathbf p_i\in\mathbf P_{OS}
        \label{eq:hyperplane-os} \\
        \mathbf q_{j}(t) \cdot{\mathbf n}(t) &\le b(t) + d_{j}, \quad\forall \mathbf q_j\in\mathbf P_{TS}
        \label{eq:hyperplane-ts} \\
        \|{\mathbf n}(t)\|_\infty &\le 1.
        \label{eq:hyperplane-norm}
    \end{align}
\end{subequations}
The constraints in \cref{eq:hyperplane-os,eq:hyperplane-ts} are enforced by
letting $\mathbf n(t)$ and $b(t)$ be optimization variables. \Cref{eq:hyperplane-norm} is a box constraint on $\mathbf n(t)$, ensuring that the hyperplane normal doesn't become too large. The minimum distance constraint in \cref{eq:minimum-distance} can be equivalently expressed using the hyperplane separation theorem by letting $\mathbf P_{OS} = \{\mathbf p_{OS}\}$ and $\mathbf P_{TS} = \{\mathbf p_{TS}\}$ in \cref{eq:minimum-distance-hyperplane}.

\subsection{COLREGS Constraints}

Finding a collision-free trajectory around an obstacle is in general a non-convex problem. Moreover, fixing the starting- and end-points of the trajectory it is not possible to continuously move the trajectory from one side of the obstacle to the other without passing through the obstacle. This is illustrated in \cref{fig:non-convex-obstacle} and is problematic from a numerical optimization perspective, as given an initial solution passing on one side of the obstacle, and the solvers incrementally stepping nature, there is no guarantee that the solver will find a solution on the other side of the obstacle as it has to pass through the obstacle to get there\todo{reformuler mer presist}. This is a simplified description of the problem, which only applies to convex problem solvers. The true behaviour is dependent on the type of solver used, and the constraint formulation.

\begin{figure}
    \centering
    \includesvg[width=0.8\textwidth]{fig/b-spline/non-convex-obstacle.svg}
    \caption{Red dots: Fixed start- and end-points of the trajectory. Black line: current trajectory. Dotted line: reference trajectory. Black circle: obstacle. A convex optimization solver will \emph{in general} not be able to find the optimal trajectory as it is not possible to continuously move the trajectory from one side of the obstacle to the other without violating the obstacle constraint.}
    \label{fig:non-convex-obstacle}
\end{figure}

For designing a COLREGS-compliant trajectory, being able to decide which side of a given target ship to pass on is essential. So to address the aforementioned issue, which side to pass the obstacle on is made a decision variable in a mixed integer programming (MIP) problem as follows:

The idea is that each target ship is represented by two obstacles, each obstacle having only one feasible side to be passed on. The passing side of the target ship is enforced by adding a point $\mathbf p_j$ to each obstacle on the opposide side of the passing side using the normal $\mathbf{\hat n}_{ref}$ of the reference trajectory $\mathbf p_{ref}$. The two obstacles are then moved into and out of the feasible region by introducing a binary variable $z_j\in\{0,1\}$ for each target ship $j$ which controls an offset $M \mathbf{\hat n}_{ref}$, where $M$ is a large positive number. More formally, the constraints are given by
\begin{subequations}\label{eq:colregs-constraints}
    \begin{align}
        \mathbf p_{j}(t) \cdot{\mathbf n}(t) &\ge b(t) + z_j M, \quad\forall \mathbf p_j\in\mathbf P_{TS}^L, \label{eq:colregs-left} \\
        \mathbf q_{j}(t) \cdot{\mathbf n}(t) &\le b(t) + d_{j} + (1 - z_j) M, \quad\forall \mathbf q_j\in\mathbf P_{TS}^R, \label{eq:colregs-right} \\
        z_j &\in \{0,1\}, \label{eq:colregs-binary}
    \end{align}
\end{subequations}
where $\mathbf P_{TS}^L$ and $\mathbf P_{TS}^R$ are the left and right target ship obstacles, respectively. The left and right target ship obstacles are defined as the two points on the opposite side of the passing side of the target ship, as shown in \cref{fig:non-convex-obstacle-mi}. The binary variable $z_j$ is used to control which side of the target ship to pass on. If $z_j = 0$, the left obstacle is moved into the feasible region, and if $z_j = 1$, the right obstacle is moved into the feasible region.

In the NLP relaxation of the MINLP (letting $z_j$ be continuous), there is now a way to continuously move the trajectory from one side of the obstacle to the other without violating any constraints. To be clear, all of the obstacles and points are active at the same time, but with a large enough chosen constant $M$, the inactive obstacles are so far away from the trajectory that they do not affect the optimization problem. This strategy is commonly referred to as the \emph{big-M} method in the Mixed Integer Programming (MIP) literature.

\begin{figure}
    \centering
    \includesvg[width=0.8\textwidth]{fig/b-spline/non-convex-obstacle-mi.svg}
    \caption{Red dots: Fixed start- and end-points of the trajectory. Black line: current trajectory. Dotted line: reference trajectory. Magenta circle: target ship. The left and right target ship obstacles are shown in blue and orange, respectively. The left obstacle is moved into the feasible region if $z_j = 0$, and the right obstacle is moved into the feasible region if $z_j = 1$.}
    \label{fig:non-convex-obstacle-mi}
\end{figure}

\section{Implementation}

The B-spline MINMPC is done in python using mainly CasADi \citep{casadi} and numpy \citep{numpy} as the main libraries. The code is divided into two main parts: a B-spline implementation and a CasAdi wrapper. 
The B-spline implementation closely follows the structure in \citet{mercy2016spline}, and takes inspiration from the CasAdi wrapper presented there, with the main modifications focusing on small optimizations, making the library more type safe, and making it easier to use with vector-valued spline functions. Support for CasADis MIP solvers was also added, which was not present in the original implementation. 
The code is available in \todo{gh repo}.

In the end, all the B-spline transformations and handling is abstracted away, letting the user create B-spline variables and constraints on symbolic variables as if they were normal CasADi variables. 

\begin{algorithm}
\caption{B-spline basis class with datafields for degree and knots. The class evaluates the B-spline basis using the Cox-de Boor recursion formula (\cref{alg:cox-de-boor}).}
\label{alg:b-spline-class}
\begin{python}
import numpy as np

@dataclass(frozen=True)
class BSplineBasis:
    """
    Class representing a B-spline basis.
    """

    degree: int
    knots: np.ndarray

    def __len__(self):
        return len(self.knots) - self.degree - 1

    def __call__(self, x: float) -> Array[Float]:
        """
        Evaluates the B-spline basis at a given point x.
        """
        return [
            cox_de_boor(tuple(self.knots), self.degree, i, x)
            for i in range(len(self))
        ]

\end{python}
\end{algorithm}

\begin{algorithm}
\caption{The algorithms for B-Spline basis transformation (\cref{alg:basis-transformation}) and combination (\cref{alg:common-basis}) implemented as methods of the B-spline basis class (\cref{alg:b-spline-class}).}
\label{alg:b-spline-class-methods}
\begin{python}
class BSplineBasis:

    ...

    def transform(
        self, other: Callable[[float], FloatArray]
    ) -> FloatMatrix:
        """
        Get the transformation matrix P such that
        P.T @ self = other.

        :param other: The other basis or function to find the transformation matrix for.
        """
        points = self.greville_abscissae
        A = self(points).T
        b = np.concatenate([other(t).T for t in points], axis=0)
        return np.linalg.solve(A, b)

    def combine(
        self, other: 'BSplineBasis', degree: int
    ) -> 'BSplineBasis':
        """
        Find common basis of two bases with different degrees in the specified degree.

        :param other: The other basis to combine with.
        :param degree: The degree of the resulting basis.
        :return: A new BSplineBasis object representing the combined basis.
        """
        def raise_degree(knots, degree):
            if degree == 0:
                return knots
            return np.sort(np.concatenate([
                np.repeat(np.unique(knots), degree), knots
            ]))
        # Raise the degree of the basis functions
        self_knots = raise_degree(self.knots, degree - self.degree)
        other_knots = raise_degree(other.knots, degree - other.degree)

        # Find the max multiplicity of each knot
        unique_knots = np.unique(np.concatenate([self_knots, other_knots]))
        multiplicity = np.zeros_like(unique_knots, dtype=int)
        for i, k in enumerate(unique_knots):
            multiplicity[i] = max(
                np.sum(self_knots == k),
                np.sum(other_knots == k)
            )
        # Create new knots
        knots = np.repeat(unique_knots, multiplicity)
        return BSplineBasis(degree, knots)
\end{python}
\end{algorithm}

\begin{algorithm}
\caption{Cox-de Boor recursion formula for B-spline basis functions (\cref{eq:b-spline-recurrence}) implemented as a recursive function using memoization.}
\label{alg:cox-de-boor}
\begin{python}
from functools import cache


@cache
def cox_de_boor(
    t: Tuple[Float], k: int, i: int, x: float
) -> float:
    """
    Evaluate the i-th B-spline basis function of degree k at x
    using the Cox-de Boor recursion formula.

    :param t: The knots for the basis.
    :param k: The degree of the basis.
    :param i: The i-th basis function to evaluate.
    :param x: The parameter value to evaluate the basis function at.
    :return: The value of the i-th basis function at x.
    """
    if k == 0:
        return int(t[i] <= x < t[i+1])

    b1 = t[i+k] - t[i]
    if b1 != 0:
        b1 = (x - t[i]) / b1
        b1 *= cox_de_boor(t, k-1, i, x)

    b2 = t[i+k+1] - t[i+1]
    if b2 != 0:
        b2 = (t[i+k+1] - x) / b2
        b2 *= cox_de_boor(t, k-1, i+1, x)

    return b1 + b2
\end{python}
\end{algorithm}
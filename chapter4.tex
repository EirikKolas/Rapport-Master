% !TeX root = main.tex
%===================================== CHAP 4 =================================

\chapter{B-spline MINMPC}\label{chap:b-spline-minmpc}

\section{Dynamic Model}
\subsection{Double Integrator}\label{sec:double-integrator}
The double integrator model is a simple model that ensures a continuous position, velocity, and acceleration for the ship. The model is described by the following equations:
\begin{subequations}\label{eq:double-integrator}
    \begin{align}
        \dot{\mathbf{p}}(t) &= \mathbf{v}(t), \label{eq:double-integrator-x} \\
        \dot{\mathbf{v}}(t) &= \mathbf{a}(t), \label{eq:double-integrator-v} \\
        \|\mathbf{v}(t)\|_2 &\leq v_{\max}, \label{eq:double-integrator-vmax} \\
        \|\mathbf{a}(t)\|_2 &\leq a_{\max}, \label{eq:double-integrator-a}
    \end{align}
\end{subequations}
where $\mathbf{p} = [p_N, p_E]^\top$ denotes the position of the ship, $\mathbf{v} = [v_N, v_E]^\top$ is the velocity, and $\mathbf{a} = [a_N, a_E]^\top$ is the acceleration in North-East coordinates. The $\|\cdot\|_2$ notation denotes the Euclidean norm, and $v_{\max}$ and $a_{\max}$ are the maximum speed and acceleration of the ship, respectively.

This continuous model can be relaxed to a B-spline model by letting $\mathbf{p}(x)$, $\mathbf{v}(x)$, and $\mathbf{a}(x)$ be spline functions on a chosen B-spline basis. It is desirable to let time be a variable in the optimization problem so that minimum time trajectories can be found. It is impractical to let the knot values of the B-spline representation of $\mathbf{p}(x)$ be optimization variables as an analysis of the Cox-de Boor recursion formula in \cref{eq:b-spline-recurrence} shows that the spline function is non-linear in these knot values. More specifically a degree $p$ B-spline with the parameter $x$ fixed, will be a polynomial of degree $p$ in the knot values. Instead, the time variable $t$ is introduced as a function of the parameter $x$, which is a common approach in these types of problems \citep{mercy2017spline,ShortestPathsConvexSets}. 

With this approach, the velocity and acceleration can now be expressed as
\begin{subequations}\label{eq:double-integrator-spline}
    \begin{align}
        \mathbf{v}(t) &= \frac{\partial \mathbf{p}}{\partial x} \frac{\partial x}{\partial t} = \frac{\mathbf{p}'}{t'},
        \label{eq:double-integrator-v-spline} \\
        \mathbf{a}(t) &= \frac{\partial \mathbf{v}}{\partial t} = \frac{\partial}{\partial t} \left(\frac{\mathbf{p}'}{t'}\right) = 
        \frac{
            t'\frac{\partial \mathbf{p}'}{\partial t} - \mathbf{p}'\frac{\partial t'}{\partial t}
            }{(t')^2} = 
        \frac{\mathbf{p}'' - \mathbf{p}'\frac{t''}{t'}}{(t')^2}.
        \label{eq:double-integrator-a-spline}
    \end{align}
\end{subequations}
Here $(\cdot)'$ and $(\cdot)''$ denotes the first and second derivative with respect to the parameter $x$, respectively. In \cref{eq:double-integrator-spline}, the inverse function theorem was used to flip the relation between $t$ and $x$. This is only possible if $t$ is a strictly increasing function of $x$, which is the case if the constraint 
\begin{equation}\label{eq:constraint-t}
    t'(x) > 0
\end{equation}
holds.  
If we in addition require the time to be positive, the velocity constraint in \cref{eq:double-integrator-vmax} becomes
\begin{equation}\label{eq:double-integrator-vmax-spline}
    \begin{aligned}
        &&\|\mathbf{v}(t)\|_2 = \left\|\frac{\mathbf{p}'}{t'}\right\|_2 &\leq v_{\max} \\
        &\implies& \|\mathbf{p}'(x)\|_2 &\leq t'(x)v_{\max} \\
        &\implies& \mathbf{p}'(x)\cdot\mathbf{p}'(x) &\leq (t'(x))^2v_{\max}^2.
    \end{aligned}
\end{equation}
To simplify the model, yet another restriction is put on the time function $t(x)$ by requiring it to be a 1st degree B-spline function. This means that the time variable is a piecewise linear function of the parameter $x$, and the second derivative of $t$ is zero, giving the simplified acceleration constraint
\begin{equation}\label{eq:double-integrator-a-spline-simplified}
    \begin{aligned}
        &&\|\mathbf{a}(t)\|_2 = \left\|\frac{\mathbf{p}''}{(t')^2}\right\|_2 &\leq a_{\max} \\
        &\implies& \|\mathbf{p}''(x)\|_2 &\leq (t'(x))^2a_{\max} \\
        &\implies& \mathbf{p}''(x)\cdot\mathbf{p}''(x) &\leq (t'(x))^4a_{\max}^2.
    \end{aligned}
\end{equation}

Now the B-Spline relaxation is fully given by the following equations:
\begin{subequations}\label{eq:double-integrator-spline-complete}
    \begin{align}
        \mathbf{p}(x) &= \sum_{i=0}^{n} \mathbf{p}_i B_{i,p,\mathbf{t}}(x), \label{eq:double-integrator-spline-complete-p} \\
        t(x) &= \sum_{i=0}^{m} t_i B_{i,1,\boldsymbol{\tau}}(x), \label{eq:double-integrator-spline-complete-t} \\
        \mathbf{p}'(x) \cdot \mathbf{p}'(x) &\leq (t'(x))^2v_{\max}^2, \label{eq:double-integrator-spline-complete-vmax} \\
        \mathbf{p}''(x) \cdot \mathbf{p}''(x) &\leq (t'(x))^4a_{\max}^2, \label{eq:double-integrator-spline-complete-a} \\
        t(x) &\geq 0, \label{eq:double-integrator-spline-complete-t-constraint} \\
        t'(x) &> 0. \label{eq:double-integrator-spline-complete-t-derivative} \end{align}
\end{subequations}
The only optimization variables needed are the B-Spline coefficients $\mathbf{p}_i\in\mathbb{R}^2$ and $t_i\in\mathbb{R}^+$ from \cref{eq:double-integrator-spline-complete-p,eq:double-integrator-spline-complete-t}, which are subject to the constraints \cref{eq:double-integrator-spline-complete-vmax,eq:double-integrator-spline-complete-a,eq:double-integrator-spline-complete-t-constraint,eq:double-integrator-spline-complete-t-derivative}.


\subsection{Dubins Model}
The ship dynamics are represented using Dubins model (unicycle model), which escribes a vehicle moving in a plane where the velocity points in the direction of the heading:
\begin{subequations}\label{eq:dubins-model}
    \begin{align}
        \dot x &= V \cos(\chi),       \label{eq:dubins-x} \\
        \dot y &= V \sin(\chi),       \label{eq:dubins-y} \\
        \dot \chi &= \omega,          \label{eq:dubins-chi} \\
        |\omega| &\leq \omega_{\max}, \label{eq:dubins-omega} \\
        0 \leq V &\leq V_{\max},      \label{eq:dubins-V} 
    \end{align}
\end{subequations}
where $x$ and $y$ are the position coordinates, $V$ is the speed, and $\chi$ is the heading angle. The control input is the turn rate $\omega$.

In order to perform a B-spline relaxation on this model, all symbols in \cref{eq:dubins-model} need to be polynomial functions of each other. One way to  achieve this, is to use the tangent half-angle substitution
\begin{equation}\label{eq:tangent-half-angle}
    r \defeq \tan\left(\frac{\chi}{2}\right).
\end{equation}
In this section, the $\defeq$ symbol denotes a change of variables, to avoid confusion with the $=$ symbol used for equality in constraints. 

Now $\cos(\chi)$ and $\sin(\chi)$ can be expressed in terms of $r$ as
\begin{subequations}\label{eq:cos-sin-r}
    \begin{align}
        \cos(\chi) &\defeq \frac{1 - r^2}{1 + r^2}, \label{eq:cos-r} \\
        \sin(\chi) &\defeq \frac{2r}{1 + r^2}.      \label{eq:sin-r}
    \end{align}
\end{subequations}
To find polynomial expressions for $\dot x$ and $\dot y$, the variable $\tilde v$ is intruduced to satisfy the equation
\begin{equation}\label{eq:constraint-V}
    V = \tilde v (1 + r^2).
\end{equation}
Now, \cref{eq:dubins-x,eq:dubins-y} can be written as
\begin{subequations}\label{eq:dubins-xy}
    \begin{align}
        \dot x &= \tilde v (1 - r^2), \label{eq:dubins-x-r} \\
        \dot y &= 2\tilde v r.        \label{eq:dubins-y-r}
    \end{align}
\end{subequations}

Up to this point, the derivation in this section has been based on the work of \citet{mercy2017spline}, which used the bicycle model. The next step is to find a polynomial expression for \cref{eq:dubins-chi} in terms of $r$ and $\omega$. This is done by first differentiating \cref{eq:tangent-half-angle} with respect to time
\begin{equation}\label{eq:rdot}
    \begin{aligned}
        &&\atan(r) &= \frac{\chi}{2}, \\
        &\implies& \frac{1}{1 + r^2} \dot r &= \frac{1}{2} \dot \chi, \\
        &\implies& \dot r &= \frac{1}{2} \dot \chi (1 + r^2),
    \end{aligned}
\end{equation}
before substituting \cref{eq:dubins-chi} into \cref{eq:rdot} to get
\begin{equation}\label{eq:rdot-omega}
    \dot r = \frac{1}{2} \omega (1 + r^2),
\end{equation}
where the dot notation denotes differentiation with respect to time.
To fulfill the constraint on $\omega$ in \cref{eq:dubins-omega}, \cref{eq:rdot-omega} is solved for $\omega$ to get
\begin{equation}\label{eq:omega-r}
    \omega \defeq \frac{2 \dot r}{1 + r^2}.
\end{equation}
Substituting \cref{eq:omega-r} into \cref{eq:rdot-omega} gives
\begin{equation}\label{eq:rdot-omega-r}
    \left|\frac{2 \dot r}{1 + r^2}\right| \leq \omega_{\max},
\end{equation}
which can be split into the two polynomial constraints
\begin{subequations}\label{eq:rdot-omega-r-constraints}
    \begin{align}
        2 \dot r &\leq \omega_{\max} (1 + r^2), \label{eq:rdot-omega-r-constraint1} \\
        2 \dot r &\geq -\omega_{\max} (1 + r^2). \label{eq:rdot-omega-r-constraint2}
    \end{align}
\end{subequations}
The speed constraint in \cref{eq:dubins-V} can similarly be expressed in terms of $r$ and $\tilde v$ as
\begin{subequations}\label{eq:V-r}
    \begin{align}
        \tilde v &\ge 0, \\
        \tilde v (1 + r^2) &\leq V_{\max}.
    \end{align}
\end{subequations}

The full model is implemented by letting $r(t)$ and $\tilde v(t)$ be spline functions on a chosen B-spline basis under the constraints in \cref{eq:rdot-omega-r-constraints,eq:V-r}, using the expressions in \cref{eq:dubins-xy} to calculate $\dot x$ and $\dot y$ using the algorithms in \cref{chap:b-spline-theory}. Notice that $V$, $\chi$, and $\omega$ are now entirely removed from the model, which is fully described by $r$ and $\tilde v$. The coefficients of the B-spline representation of $\dot r$ are simply linear combinations of the coefficients of $r$, as explained in \cref{sec:derivative} and the position can be found by integrating the expressions in \cref{eq:dubins-xy}.

To implement the inequality constraint $f(t) \le g(t)$, for two spline functions $f(t)$ and $g(t)$, the constraint is enforced by ensuring the coefficients of the B-spline representation of $f(t) - g(t)$ are non-positive, exploiting the convex hull property of B-splines. 

\section{Target Ships}
\begin{itemize}
    \item hyperplane separation theorem
    \item COLREGS constraints
    \item mixed integer programming
\end{itemize}

\subsection{Hyperplane Separation Theorem}
The standard way to enforce collision constraints between the OS and TS is to apply a minumum distance constraint between the two ships as
\begin{equation}\label{eq:minimum-distance}
    (\mathbf p_{\text{OS}} - \mathbf p_{\text{TS}}) \cdot (\mathbf p_{\text{OS}} - \mathbf p_{\text{TS}}) \geq d_{\text{min}}^2,
\end{equation}
where $\mathbf p_{\text{OS}}$ and $\mathbf p_{\text{TS}}$ are the positions of the OS and TS, respectively, and $d_{\text{min}}$ is the minimum distance between the two ships. The $\cdot$ symbol denotes the dot product. 

The hyperplane separation theorem states that for two disjoint convex sets $\mathcal A$ and $\mathcal B$, there exists $\mathbf n\in \mathbb R^n\backslash\{\mathbf0\}$ and $b\in\mathbb R$ such that the hyperplane $H=\{\mathbf x\in\mathbb R^n \mid \mathbf n^\top \mathbf x = b\}$ separates $\mathcal A$ and $\mathcal B$ \citep{Boyd2004-ih}. In other words, there exists a function $a^\top x - b$ that is non-negative for all $x \in \mathcal A$ and non-positive for all $x \in \mathcal B$. 

Using this theorem the collision avoidance problem can essentially be transformed into a classification problem. The objective is to find a line that separates points $\mathbf p_i$ representing the OS from points $\mathbf q_j$ belonging to the TS.
\begin{subequations}\label{eq:minimum-distance-hyperplane}
    \begin{align}
        \mathbf p_{i}(t) \cdot{\mathbf n}(t) &\ge b(t), \quad\forall \mathbf p_i\in\mathbf P_{OS}
        \label{eq:hyperplane-os} \\
        \mathbf q_{j}(t) \cdot{\mathbf n}(t) &\le b(t) + d_{j}, \quad\forall \mathbf q_j\in\mathbf P_{TS}
        \label{eq:hyperplane-ts} \\
        \|{\mathbf n}(t)\|_\infty &\le 1.
        \label{eq:hyperplane-norm}
    \end{align}
\end{subequations}
The constraints in \cref{eq:hyperplane-os,eq:hyperplane-ts} are enforced by
letting $\mathbf n(t)$ and $b(t)$ be optimization variables. \Cref{eq:hyperplane-norm} is a box constraint on $\mathbf n(t)$, ensuring that the hyperplane normal doesn't become too large. The minimum distance constraint in \cref{eq:minimum-distance} can be equivalently expressed using the hyperplane separation theorem by letting $\mathbf P_{OS} = \{\mathbf p_{OS}\}$ and $\mathbf P_{TS} = \{\mathbf p_{TS}\}$ in \cref{eq:minimum-distance-hyperplane}.

\subsection{COLREGS Constraints}

Finding a collision-free trajectory around an obstacle is in general a non-convex problem. Moreover, fixing the starting- and end-points of the trajectory it is not possible to continuously move the trajectory from one side of the obstacle to the other without passing through the obstacle. This is illustrated in \cref{fig:non-convex-obstacle} and is problematic from a numerical optimization perspective, as given an initial solution passing on one side of the obstacle, and the solvers incrementally stepping nature, there is no guarantee that the solver will find a solution on the other side of the obstacle as it has to pass through the obstacle to get there\todo{reformuler mer presist}. This is a simplified description of the problem, which only applies to convex problem solvers. The true behaviour is dependent on the type of solver used, and the constraint formulation.

\begin{figure}
    \centering
    \includesvg[width=0.8\textwidth]{fig/b-spline/non-convex-obstacle.svg}
    \caption{Red dots: Fixed start- and end-points of the trajectory. Black line: current trajectory. Dotted line: reference trajectory. Black circle: obstacle. A convex optimization solver will \emph{in general} not be able to find the optimal trajectory as it is not possible to continuously move the trajectory from one side of the obstacle to the other without violating the obstacle constraint.}
    \label{fig:non-convex-obstacle}
\end{figure}

For designing a COLREGS-compliant trajectory, being able to decide which side of a given target ship to pass on is essential. So to address the aforementioned issue, which side to pass the obstacle on is made a decision variable in a mixed integer programming (MIP) problem as follows:

The idea is that each target ship is represented by two obstacles, each obstacle having only one feasible side to be passed on. The passing side of the target ship is enforced by adding a point $\mathbf p_j$ to each obstacle on the opposide side of the passing side using the normal $\mathbf{\hat n}_{ref}$ of the reference trajectory $\mathbf p_{ref}$. The two obstacles are then moved into and out of the feasible region by introducing a binary variable $z_j\in\{0,1\}$ for each target ship $j$ which controls an offset $M \mathbf{\hat n}_{ref}$, where $M$ is a large positive number. More formally, the constraints are given by
\begin{subequations}\label{eq:colregs-constraints}
    \begin{align}
        \mathbf p_{j}(t) \cdot{\mathbf n}(t) &\ge b(t) + z_j M, \quad\forall \mathbf p_j\in\mathbf P_{TS}^L, \label{eq:colregs-left} \\
        \mathbf q_{j}(t) \cdot{\mathbf n}(t) &\le b(t) + d_{j} + (1 - z_j) M, \quad\forall \mathbf q_j\in\mathbf P_{TS}^R, \label{eq:colregs-right} \\
        z_j &\in \{0,1\}, \label{eq:colregs-binary}
    \end{align}
\end{subequations}
where $\mathbf P_{TS}^L$ and $\mathbf P_{TS}^R$ are the left and right target ship obstacles, respectively. The left and right target ship obstacles are defined as the two points on the opposite side of the passing side of the target ship, as shown in \cref{fig:non-convex-obstacle-mi}. The binary variable $z_j$ is used to control which side of the target ship to pass on. If $z_j = 0$, the left obstacle is moved into the feasible region, and if $z_j = 1$, the right obstacle is moved into the feasible region.

In the NLP relaxation of the MINLP (letting $z_j$ be continuous), there is now a way to continuously move the trajectory from one side of the obstacle to the other without violating any constraints. To be clear, all of the obstacles and points are active at the same time, but with a large enough chosen constant $M$, the inactive obstacles are so far away from the trajectory that they do not affect the optimization problem. This strategy is commonly referred to as the \emph{big-M} method in the Mixed Integer Programming (MIP) literature.

\begin{figure}
    \centering
    \includesvg[width=0.8\textwidth]{fig/b-spline/non-convex-obstacle-mi.svg}
    \caption{Red dots: Fixed start- and end-points of the trajectory. Black line: current trajectory. Dotted line: reference trajectory. The left and right target ship obstacles are shown in blue and orange, respectively. The left obstacle is moved into the feasible region if $z_j = 0$, and the right obstacle is moved into the feasible region if $z_j = 1$.}
    \label{fig:non-convex-obstacle-mi}
\end{figure}



\section{The Objective Function}
The goals of the objective function should be 1) to find a safe, COLREGS-compliant trajectory, and 2) to follow a reference trajectory. These objectives are conflicting as rule 8b) of the COLREGS (see \cref{sec:colregs}) states that any alteration of course should be large enough to be readily apparent to another vessel. Following a reference trajectory on the other hand often involves the squared error between the vessel and the reference trajectory, which inherently penalizes sudden deviations in course. 
Thus a careful choice of the objective function is important to ensure robust and predictable behaviour. 
The following section will examine the behavior of the B-spline method when applied to a basic reference-following task. The subsequent section will then address COLREGS considerations.


\subsection{Reference Following}
\label{sec:oscillations}
Finding a reference-following trajectory using B-splines can be viewed as a penalized regression problem where the reference trajectory is the data to be fitted and the B-spline is the model used to fit data. In the literature, there are two common ways of fitting a B-Spline to data: 1) O'Sullivan splines \citep{OSullivan1986} or smoothing splines, which balances smoothness and fidelity to the data by penalizing the second derivative of the spline\footnote{More specifically the integral over the square of the second derivative.}, and 2) the P-Spline \citep{Eilers1996}, which penalizes the difference of coefficients directly. The second approach achieves more flexibility, as the penalty function is independent of the degree of the B-spline \citep{Eilers2021}. This section applies these two approaches to a constrained optimal control problem, comparing using the discrete and continuous squared reference error as the cost function. 

% Using the definite integral over the squared reference error as a cost function, gives oscillations in the trajectory. This is due to the fact that the integral is less sensitive to high frequency oscillations than the sum of squared coefficients of the reference error spline. The integral puts more emphasis on the overall global shape of the trajectory, while the sum of squared coefficients puts more emphasis on the local shape. The oscillations can be damped by penalizing acceleration, but this is does not remove the oscillations completely. Further increasing the penalty on acceleration will lead to very slow convergence.
% The oscillations can be removed by using the sum of squared coefficients of the reference error as a cost function.

More concretely, consider the problem of following a reference trajectory, while ensuring that the OS does not exceed a maximum speed:
\begin{equation}\label{eq:conservativeness-optimization}
    \begin{aligned}
        \min_{\mathbf c} \quad & \mathcal{O} \\
        \text{s.t.} \quad \mathbf p_\text{os}(0) &= \mathbf p_0, \\
                     \mathbf p_\text{os} &= \mathbf B^\top(x) \mathbf c, \\
                     \mathbf p_\text{ref} &= \mathbf B_\text{ref}^\top(x) \mathbf c_\text{ref}, \\
                     \langle p_\text{os}', p_\text{os}' \rangle &\le v_\text{max}^2,
    \end{aligned}
\end{equation}
where $\mathbf p_\text{os}$ is the position of the OS and $\mathbf p_\text{ref}$ is the reference position in their respecive B-spline bases $\mathbf B$ and $\mathbf B_\text{ref}$. The objective function $\mathcal{O}$ to be considered has two different formulations, one based on the sum of squared coefficients of the reference error and one based on the definite integral over the squared reference error. The two formulations are given by
\begin{equation}\label{eq:conservativeness-objective}
    \mathcal{O} = \begin{cases}
        \|\text{coeffs}(\mathbf p_\text{os} - \mathbf p_\text{ref})\|_\text{F}^2, & \text{discrete cost} \\
        \int_0^1 \left(\mathbf p_\text{os}(x) - \mathbf p_\text{ref}(x)\right)^\top \left(\mathbf p_\text{os}(x) - \mathbf p_\text{ref}(x)\right) dx, & \text{continuous cost}
    \end{cases}
\end{equation}


The $\text{coeffs}(\cdot)$ function extracts the control points $\mathbf c$ of the B-spline function $f(x)=\mathbf B(x)^\top\mathbf c$ and $\|\cdot\|_\text{F}^2$ is the squared Frobenius norm, given by
\begin{equation}
    \|\mathbf A\|_\text{F}^2 = \sum_{i,j} a_{ij}^2,
\end{equation}
where $\mathbf A$ is a matrix and $a_{ij}$ is the element in the $i$-th row and $j$-th column of $\mathbf A$. All other operations on the B-spline functions are done using the algorithms in \cref{chap:b-spline-theory}. 
 
This optimization problem is then solved with a varying number $N$ of uniform B-spline basis functions $\mathbf B$, and the resulting trajectories are shown in \cref{fig:conservativeness} with the parameters for the optimization problem set to
\begin{equation}
    \begin{aligned}
        \mathbf p_0 &= \begin{bmatrix} 1 & 0 \end{bmatrix}
        \mathbf B_\text{ref} &= \mathbf B_{p=1,\mathbf t =\{0, 0, 1, 1\}} \\
        \mathbf c_\text{ref} &= \begin{bmatrix}
            0 & 0 \\
            0 & 3
        \end{bmatrix} \\
        v_\text{max} &= 6, \\
    \end{aligned}
\end{equation}


\begin{figure}
    \centering
    \begin{subfigure}[b]{\textwidth}
        \centering
        \includesvg[width=\textwidth,pretex=\small]{fig/conservativeness/conservativeness_traj_coeffs_degree_3.svg}
        \caption{Trajectory using the sum of squared coefficients of the reference error as a cost function.}
        \label{fig:conservativeness-traj-coeffs}
    \end{subfigure}
    \hfill
    \begin{subfigure}[b]{\textwidth}
        \centering
        \includesvg[width=\textwidth,pretex=\small]{fig/conservativeness/conservativeness_traj_integral_degree_3.svg}
        \caption{Trajectory using the definite integral over the squared reference error as a cost function.}
        \label{fig:conservativeness-traj-integral}
    \end{subfigure}
    \caption{Comparison of optimal trajectory in \cref{eq:conservativeness-optimization} for a uniform cubic B-spline for $N\in\{4,\ldots,20\}$.
    % The top plot shows the trajectory using the sum of squared coefficients, while the bottom plot shows the trajectory using the definite integral.
    }
    \label{fig:conservativeness-traj}
\end{figure}

\begin{figure}
    \centering
    \includesvg[width=\textwidth,pretex=\small]{fig/conservativeness/compare_conservativeness_degree_3.svg}
    \caption{Comparison of the performance using the sum of squared coefficients of the reference error and the definite integral over the squared reference error as a cost function. The results are shown for a uniform cubic B-spline against a varying number of B-spline basis functions, $N$.}
    \label{fig:conservativeness}
\end{figure}


\begin{figure}
    \centering
    \includesvg[width=\textwidth,pretex=\small]{fig/conservativeness/compare_conservativeness_coeffs_all_degrees.svg}
    \caption{Logaritmic plot of the Integral of the square error using the sum of squared coefficients as the cost function. The conservativeness is in general worse for larger degrees of the B-spline basis. The lowest obbserved value is subtracted from all values in the plot. This is why some values for $p=4$ appear to go towards negative infinity.}
    \label{fig:conservativeness-coeffs}
\end{figure}

\subsection{COLREGS Objectives}


\subsection{The Final Objective Function}


\section{Implementation}\label{sec:python-implementation}

The B-spline MINMPC is implemented in python using CasADi \citep{casadi} and numpy \citep{numpy} as the main libraries. The code is divided into two main parts: a B-spline implementation and a CasAdi wrapper. 
The B-spline implementation closely follows the structure in \citet{mercy2016spline}, and takes inspiration from the CasAdi wrapper presented there. The main modifications are focused around on small optimizations, making the library more type safe, and making it easier to use with vector-valued spline functions. Support for CasADi's MIP solvers was also added, which was not present in the original implementation. 
The code is available in \todo{gh repo}.

In the end, all the B-spline transformations and handling is abstracted away, letting the user create B-spline variables and constraints on symbolic variables as if they were normal CasADi variables. 

\subsection{Optimization Problem Class}
This section will present the public interface of the Optimization Problem class. The class is designed to be used with CasADi and operates similarly to CasADi's own Opti framework. It differs from CasADi's Opti framework in that it supports B-spline variables and constraints, as well as binary and integer variables more seamlessly. The Optimization Problem class is also modular, in the sense that different objects can be used to represent e.g. the own ship, target ship and reference, before being combined into a single optimization problem. This will be clarified in the following example.

\begin{example}{Optimization Problem Setup}
\begin{python}
from cs_mpc import OptiObject, OptiCollection, BSplineBasis


degree = 3
n_control_points = 10
basis = create_uniform_b_spline_basis(
    degree, n_control_points, 0, 1
)

own_ship = OptiObject('own_ship')
os_pos = own_ship.declare_spline_variable('pos', n_dim=2, basis=basis)
os_pos_0 = own_ship.declare_parameter('pos_0', n_dim=2)
os_pos_f = own_ship.declare_parameter('pos_f', n_dim=2)

own_ship.declare_constraint(os_pos(0) - os_pos_0, lb=0, ub=0)
own_ship.declare_constraint(os_pos(1) - os_pos_f, lb=0, ub=0)

end_err = os_pos - os_pos_f
own_ship.declare_objective(end_err.dot(end_err).definite_integral(0,1))


target_ship = OptiObject('target_ship')
ts_pos = target_ship.declare_spline_parameter('pos', n_dim=2, basis=basis)
ts_err = os_pos - ts_pos
min_dist = target_ship.declare_parameter('min_dist', n_dim=1)
target_ship.declare_constraint(ts_err.dot(ts_err) - min_dist**2, lb=0)


opti = OptiCollection([own_ship, target_ship])
own_ship.set_value('pos_0', [0, 0])
own_ship.set_value('pos_f', [1000, 0])
target_ship.set_value('pos', ...)
target_ship.set_value('min_dist', 10)
sol = opti.solve()

\end{python}
\end{example}
